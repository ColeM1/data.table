# SOME DESCRIPTIVE TITLE.
# Copyright (C) 2019
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"Report-Msgid-Bugs-To: \n"
"POT-Creation-Date: 2019-10-13 16:58+0800\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: \n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=CHARSET\n"
"Content-Transfer-Encoding: 8bit\n"

#: assign.c:9
msgid "Internal error: finalizer hasn't received an ExternalPtr"
msgstr ""

#: assign.c:11
msgid "Internal error: finalizer's ExternalPtr doesn't see names in tag"
msgstr ""

#: assign.c:14
#, c-format
msgid "Internal error: finalizer sees l=%d, tl=%d"
msgstr ""

#: assign.c:126
msgid "Internal error: .internal.selfref ptr is not NULL or R_NilValue"
msgstr ""

#: assign.c:128
msgid "Internal error: .internal.selfref tag isn't NULL or a character vector"
msgstr ""

#: assign.c:170
msgid "Internal error: length(names)>0 but <length(dt)"
msgstr ""

#: assign.c:199
msgid "alloccol has been passed a NULL dt"
msgstr ""

#: assign.c:200
msgid "dt passed to alloccol isn't type VECSXP"
msgstr ""

#: assign.c:202
msgid ""
"dt passed to alloccol has no class attribute. Please report result of "
"traceback() to data.table issue tracker."
msgstr ""

#: assign.c:207
#, c-format
msgid "Internal error: length of names (%d) is not length of dt (%d)"
msgstr ""

#: assign.c:217
msgid "Internal error, tl of class is marked but tl<0."
msgstr ""

#: assign.c:218
#, c-format
msgid ""
"Internal error, please report (including result of sessionInfo()) to data."
"table issue tracker: tl (%d) < l (%d) but tl of class is marked."
msgstr ""

#: assign.c:229
msgid ""
"Has getOption('datatable.alloccol') somehow become unset? It should be a "
"number, by default 1024."
msgstr ""

#: assign.c:231
#, c-format
msgid ""
"getOption('datatable.alloccol') should be a number, by default 1024. But its "
"type is '%s'."
msgstr ""

#: assign.c:233
#, c-format
msgid ""
"getOption('datatable.alloc') is a numeric vector ok but its length is %d. "
"Its length should be 1."
msgstr ""

#: assign.c:236
#, c-format
msgid "getOption('datatable.alloc')==%d.  It must be >=0 and not NA."
msgstr ""

#: assign.c:241 fsort.c:109 nafill.c:73
msgid "verbose must be TRUE or FALSE"
msgstr ""

#: assign.c:289
msgid "assign has been passed a NULL dt"
msgstr ""

#: assign.c:290
msgid "dt passed to assign isn't type VECSXP"
msgstr ""

#: assign.c:292
msgid ""
".SD is locked. Updating .SD by reference using := or set are reserved for "
"future use. Use := in j directly. Or use copy(.SD) as a (slow) last resort, "
"until shallow() is exported."
msgstr ""

#: assign.c:300
msgid "Internal error: dt passed to Cassign is not a data.table or data.frame"
msgstr ""

#: assign.c:304
msgid "dt passed to assign has no names"
msgstr ""

#: assign.c:306
#, c-format
msgid "Internal error in assign: length of names (%d) is not length of dt (%d)"
msgstr ""

#: assign.c:308
msgid ""
"data.table is NULL; malformed. A null data.table should be an empty list. "
"typeof() should always return 'list' for data.table."
msgstr ""

#: assign.c:325
#, c-format
msgid ""
"i is type '%s'. Must be integer, or numeric is coerced with warning. If i is "
"a logical subset, simply wrap with which(), and take the which() outside the "
"loop if possible for efficiency."
msgstr ""

#: assign.c:331
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]."
msgstr ""

#: assign.c:361
msgid ""
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that. data.table's are over-allocated and don't "
"shallow copy."
msgstr ""

#: assign.c:375
#, c-format
msgid ""
"j is type '%s'. Must be integer, character, or numeric is coerced with "
"warning."
msgstr ""

#: assign.c:377
msgid ""
"Can't assign to the same column twice in the same query (duplicates "
"detected)."
msgstr ""

#: assign.c:378
msgid "newcolnames is supplied but isn't a character vector"
msgstr ""

#: assign.c:390
#, c-format
msgid ""
"Supplied %d columns to be assigned an empty list (which may be an empty data."
"table or data.frame since they are lists too). "
msgstr ""

#: assign.c:398
#, c-format
msgid ""
"Supplied %d columns to be assigned %d items. Please see NEWS for v1.12.2."
msgstr ""

#: assign.c:406
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. "
"set() on a data.frame is for changing existing columns, not adding new ones. "
"Please use a data.table for that."
msgstr ""

#: assign.c:407
#, c-format
msgid ""
"Item %d of column numbers in j is %d which is outside range [1,ncol=%d]. Use "
"column names instead in j to add new columns."
msgstr ""

#: assign.c:412
msgid "When deleting columns, i should not be provided"
msgstr ""

#: assign.c:418
#, c-format
msgid ""
"RHS of assignment to existing column '%s' is zero length but not NULL. If "
"you intend to delete the column use NULL. Otherwise, the RHS must have "
"length > 0; e.g., NA_integer_. If you are trying to change the column type "
"to be an empty list column then, as with all column type changes, provide a "
"full length RHS vector such as vector('list',nrow(DT)); i.e., 'plonk' in the "
"new column."
msgstr ""

#: assign.c:423
#, c-format
msgid ""
"Internal error in assign.c: length(newcolnames)=%d, length(names)=%d, coln=%d"
msgstr ""

#: assign.c:435
#, c-format
msgid ""
"Can't assign to column '%s' (type 'factor') a value of type '%s' (not "
"character, factor, integer or numeric)"
msgstr ""

#: assign.c:440
#, c-format
msgid ""
"Supplied %d items to be assigned to %d items of column '%s'. If you wish to "
"'recycle' the RHS please "
msgstr ""

#: assign.c:451
msgid ""
"This data.table has either been loaded from disk (e.g. using readRDS()/"
"load()) or constructed manually (e.g. using structure()). Please run setDT() "
"or setalloccol() on it first (to pre-allocate space for new columns) before "
"assigning by reference to it."
msgstr ""

#: assign.c:452
#, c-format
msgid ""
"Internal error: oldtncol(%d) < oldncol(%d). Please report to data.table "
"issue tracker, including result of sessionInfo()."
msgstr ""

#: assign.c:456
#, c-format
msgid ""
"Internal error: DT passed to assign has not been allocated enough column "
"slots. l=%d, tl=%d, adding %d"
msgstr ""

#: assign.c:458
msgid ""
"It appears that at some earlier point, names of this data.table have been "
"reassigned. Please ensure to use setnames() rather than names<- or "
"colnames<-. Otherwise, please report to data.table issue tracker."
msgstr ""

#: assign.c:462
#, c-format
msgid "Internal error: selfrefnames is ok but tl names [%d] != tl [%d]"
msgstr ""

#: assign.c:473
msgid ""
"Internal error: earlier error 'When deleting columns, i should not be "
"provided' did not happen."
msgstr ""

#: assign.c:566
msgid "Internal error: index name ends with trailing __"
msgstr ""

#: assign.c:571
msgid "Internal error: Couldn't allocate memory for s4."
msgstr ""

#: assign.c:582
msgid "Internal error: Couldn't allocate memory for s5."
msgstr ""

#: assign.c:689
#, c-format
msgid "Internal error: recycle length error not caught earlier. slen=%d len=%d"
msgstr ""

#: assign.c:693
msgid "Internal error: memrecycle has received NULL colname"
msgstr ""

#: assign.c:719
#, c-format
msgid ""
"Cannot assign 'factor' to '%s'. Factors can only be assigned to factor, "
"character or list columns."
msgstr ""

#: assign.c:733
#, c-format
msgid ""
"Assigning factor numbers to column %d named '%s'. But %d is outside the "
"level range [1,%d]"
msgstr ""

#: assign.c:741
#, c-format
msgid ""
"Assigning factor numbers to column %d named '%s'. But %f is outside the "
"level range [1,%d], or is not a whole number."
msgstr ""

#: assign.c:747
#, c-format
msgid ""
"Cannot assign '%s' to 'factor'. Factor columns can be assigned factor, "
"character, NA in any type, or level numbers."
msgstr ""

#: assign.c:768
msgid ""
"Internal error: levels of target are either not unique or have truelength<0"
msgstr ""

#: assign.c:807
#, c-format
msgid "Unable to allocate working memory of %d bytes to combine factor levels"
msgstr ""

#: assign.c:814
msgid "Internal error: extra level check sum failed"
msgstr ""

#: assign.c:839
#, c-format
msgid ""
"Cannot coerce 'list' RHS to 'integer64' to match the type of the target "
"column (column %d named '%s')."
msgstr ""

#: assign.c:945
#, c-format
msgid "type '%s' cannot be coerced to '%s'"
msgstr ""

#: assign.c:1065
msgid ""
"To assign integer64 to a character column, please use as.character() for "
"clarity."
msgstr ""

#: assign.c:1076
#, c-format
msgid "Unsupported column type in assign.c:memrecycle '%s'"
msgstr ""

#: assign.c:1123
#, c-format
msgid "Internal error: writeNA passed a vector of type '%s'"
msgstr ""

#: assign.c:1154
#, c-format
msgid ""
"Internal error: savetl_init checks failed (%d %d %p %p). please report to "
"data.table issue tracker."
msgstr ""

#: assign.c:1162
#, c-format
msgid "Failed to allocate initial %d items in savetl_init"
msgstr ""

#: assign.c:1171
#, c-format
msgid ""
"Internal error: reached maximum %d items for savetl. Please report to data."
"table issue tracker."
msgstr ""

#: assign.c:1178
#, c-format
msgid "Failed to realloc saveds to %d items in savetl"
msgstr ""

#: assign.c:1184
#, c-format
msgid "Failed to realloc savedtl to %d items in savetl"
msgstr ""

#: assign.c:1207
msgid "x must be a character vector"
msgstr ""

#: assign.c:1208
msgid "'which' must be an integer vector"
msgstr ""

#: assign.c:1209
msgid "'new' must be a character vector"
msgstr ""

#: assign.c:1210
#, c-format
msgid "'new' is length %d. Should be the same as length of 'which' (%d)"
msgstr ""

#: assign.c:1213
#, c-format
msgid ""
"Item %d of 'which' is %d which is outside range of the length %d character "
"vector"
msgstr ""

#: assign.c:1223
msgid "dt passed to setcolorder has no names"
msgstr ""

#: assign.c:1225
#, c-format
msgid "Internal error: dt passed to setcolorder has %d columns but %d names"
msgstr ""

#: assign.c:1232
msgid ""
"Internal error: o passed to Csetcolorder contains an NA or out-of-bounds"
msgstr ""

#: assign.c:1234
msgid "Internal error: o passed to Csetcolorder contains a duplicate"
msgstr ""

#: between.c:12
#, c-format
msgid ""
"Incompatible vector lengths: length(x)==%d length(lower)==%d length(upper)=="
"%d. Each should be either length 1 or the length of the longest."
msgstr ""

#: between.c:16
msgid "incbounds must be TRUE or FALSE"
msgstr ""

#: between.c:19
msgid "NAbounds must be TRUE or NA"
msgstr ""

#: between.c:22
msgid "check must be TRUE or FALSE"
msgstr ""

#: between.c:64
#, c-format
msgid "Item %d of lower (%d) is greater than item %d of upper (%d)"
msgstr ""

#: between.c:88
msgid "x is integer64 but lower and/or upper are not."
msgstr ""

#: between.c:95
#, c-format
msgid "Item %d of lower (%lld) is greater than item %d of upper (%lld)"
msgstr ""

#: between.c:115
msgid ""
"x is not integer64 but lower and/or upper is integer64. Please align classes."
msgstr ""

#: between.c:122
#, c-format
msgid "Item %d of lower (%f) is greater than item %d of upper (%f)"
msgstr ""

#: between.c:172
#, c-format
msgid "Item %d of lower ('%s') is greater than item %d of upper ('%s')"
msgstr ""

#: between.c:190
#, c-format
msgid ""
"Internal error: between.c unsupported type '%s' should have been caught at R "
"level"
msgstr ""

#: bmerge.c:48
msgid "Internal error: icols is not integer vector"
msgstr ""

#: bmerge.c:49
msgid "Internal error: xcols is not integer vector"
msgstr ""

#: bmerge.c:50
#, c-format
msgid "Internal error: length(icols) [%d] > length(xcols) [%d]"
msgstr ""

#: bmerge.c:57
#, c-format
msgid "Internal error. icols[%d] is NA"
msgstr ""

#: bmerge.c:58
#, c-format
msgid "Internal error. xcols[%d] is NA"
msgstr ""

#: bmerge.c:59
#, c-format
msgid "icols[%d]=%d outside range [1,length(i)=%d]"
msgstr ""

#: bmerge.c:60
#, c-format
msgid "xcols[%d]=%d outside range [1,length(x)=%d]"
msgstr ""

#: bmerge.c:63
#, c-format
msgid "typeof x.%s (%s) != typeof i.%s (%s)"
msgstr ""

#: bmerge.c:70
msgid "roll is character but not 'nearest'"
msgstr ""

#: bmerge.c:71
msgid "roll='nearest' can't be applied to a character column, yet."
msgstr ""

#: bmerge.c:74
msgid "Internal error: roll is not character or double"
msgstr ""

#: bmerge.c:79
msgid "rollends must be a length 2 logical vector"
msgstr ""

#: bmerge.c:89 uniqlist.c:270
msgid ""
"Internal error: invalid value for 'mult'. please report to data.table issue "
"tracker"
msgstr ""

#: bmerge.c:93
msgid ""
"Internal error: opArg is not an integer vector of length equal to length(on)"
msgstr ""

#: bmerge.c:96
msgid "Internal error: nqgrpArg must be an integer vector"
msgstr ""

#: bmerge.c:102
msgid "Intrnal error: nqmaxgrpArg is not a positive length-1 integer vector"
msgstr ""

#: bmerge.c:111
msgid "Internal error in allocating memory for non-equi join"
msgstr ""

#: bmerge.c:156
msgid "Internal error: xoArg is not an integer vector"
msgstr ""

#: bmerge.c:271 bmerge.c:379
#, c-format
msgid ""
"Internal error in bmerge_r for '%s' column. Unrecognized value op[col]=%d"
msgstr ""

#: bmerge.c:303
#, c-format
msgid "Only '==' operator is supported for columns of type %s."
msgstr ""

#: bmerge.c:410
#, c-format
msgid "Type '%s' not supported for joining/merging"
msgstr ""

#: bmerge.c:468
msgid "Internal error: xlow!=xupp-1 || xlow<xlowIn || xupp>xuppIn"
msgstr ""

#: chmatch.c:4
#, c-format
msgid "x is type '%s' (must be 'character' or NULL)"
msgstr ""

#: chmatch.c:5
#, c-format
msgid "table is type '%s' (must be 'character' or NULL)"
msgstr ""

#: chmatch.c:6
msgid "Internal error: either chin or chmatchdup should be true not both"
msgstr ""

#: chmatch.c:30
#, c-format
msgid ""
"Internal error: CHARSXP '%s' has a negative truelength (%d). Please file an "
"issue on the data.table tracker."
msgstr ""

#: chmatch.c:60
#, c-format
msgid ""
"Failed to allocate %lld bytes working memory in chmatchdup: length(table)=%d "
"length(unique(table))=%d"
msgstr ""

#: cj.c:89
#, c-format
msgid "Type '%s' not supported by CJ."
msgstr ""

#: coalesce.c:5
msgid "Internal error in coalesce.c: input is list(...) at R level"
msgstr ""

#: coalesce.c:7
msgid ""
"Internal error in coalesce.c: argument 'inplaceArg' must be TRUE or FALSE"
msgstr ""

#: coalesce.c:16
msgid ""
"The first argument is a list, data.table or data.frame. In this case there "
"should be no other arguments provided."
msgstr ""

#: coalesce.c:32
#, c-format
msgid ""
"Item 1 is a factor but item %d is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""

#: coalesce.c:34
#, c-format
msgid ""
"Item %d is a factor but its levels are not identical to the first item's "
"levels."
msgstr ""

#: coalesce.c:38
#, c-format
msgid ""
"Item %d is a factor but item 1 is not a factor. When factors are involved, "
"all items must be factor."
msgstr ""

#: coalesce.c:41
#, c-format
msgid ""
"Item %d is type %s but the first item is type %s. Please coerce before "
"coalescing."
msgstr ""

#: coalesce.c:43
#, c-format
msgid "Item %d has a different class than item 1."
msgstr ""

#: coalesce.c:46
#, c-format
msgid ""
"Item %d is length %d but the first item is length %d. Only singletons are "
"recycled."
msgstr ""

#: coalesce.c:166
#, c-format
msgid "Unsupported type: %s"
msgstr ""

#: dogroups.c:14
msgid "Internal error: order not integer vector"
msgstr ""

#: dogroups.c:15
msgid "Internal error: starts not integer"
msgstr ""

#: dogroups.c:16
msgid "Internal error: lens not integer"
msgstr ""

#: dogroups.c:18
msgid "Internal error: jiscols not NULL but o__ has length"
msgstr ""

#: dogroups.c:19
msgid "Internal error: xjiscols not NULL but o__ has length"
msgstr ""

#: dogroups.c:20
msgid "'env' should be an environment"
msgstr ""

#: dogroups.c:39
#, c-format
msgid ""
"Internal error: unsupported size-0 type '%s' in column %d of 'by' should "
"have been caught earlier"
msgstr ""

#: dogroups.c:43
#, c-format
msgid "!length(bynames)[%d]==length(groups)[%d]==length(grpcols)[%d]"
msgstr ""

#: dogroups.c:62
msgid "row.names attribute of .SD not found"
msgstr ""

#: dogroups.c:64
#, c-format
msgid ""
"row.names of .SD isn't integer length 2 with NA as first item; i.e., ."
"set_row_names(). [%s %d %d]"
msgstr ""

#: dogroups.c:69
msgid "length(names)!=length(SD)"
msgstr ""

#: dogroups.c:73
#, c-format
msgid ""
"Internal error: size-0 type %d in .SD column %d should have been caught "
"earlier"
msgstr ""

#: dogroups.c:83
msgid "length(xknames)!=length(xSD)"
msgstr ""

#: dogroups.c:87
#, c-format
msgid ""
"Internal error: type %d in .xSD column %d should have been caught by now"
msgstr ""

#: dogroups.c:91
#, c-format
msgid "length(iSD)[%d] != length(jiscols)[%d]"
msgstr ""

#: dogroups.c:92
#, c-format
msgid "length(xSD)[%d] != length(xjiscols)[%d]"
msgstr ""

#: dogroups.c:155 dogroups.c:184
msgid "Internal error. Type of column should have been checked by now"
msgstr ""

#: dogroups.c:273
#, c-format
msgid "j evaluates to type '%s'. Must evaluate to atomic vector or list."
msgstr ""

#: dogroups.c:281
msgid ""
"All items in j=list(...) should be atomic vectors or lists. If you are "
"trying something like j=list(.SD,newcol=mean(colA)) then use := by group "
"instead (much quicker), or cbind or merge afterwards."
msgstr ""

#: dogroups.c:291
msgid ""
"RHS is NULL when grouping :=. Makes no sense to delete a column by group. "
"Perhaps use an empty vector instead."
msgstr ""

#: dogroups.c:295
#, c-format
msgid ""
"Supplied %d items to be assigned to group %d of size %d in column '%s'. The "
"RHS length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""

#: dogroups.c:304
msgid ""
"Internal error: Trying to add new column by reference but tl is full; "
"setalloccol should have run first at R level before getting to this point in "
"dogroups"
msgstr ""

#: dogroups.c:326
msgid "j doesn't evaluate to the same number of columns for each group"
msgstr ""

#: dogroups.c:360
#, c-format
msgid ""
"Column %d of j's result for the first group is NULL. We rely on the column "
"types of the first result to decide the type expected for the remaining "
"groups (and require consistency). NULL columns are acceptable for later "
"groups (and those are replaced with NA of appropriate type and recycled) but "
"not for the first. Please use a typed empty vector instead, such as "
"integer() or numeric()."
msgstr ""

#: dogroups.c:386
#, c-format
msgid "dogroups: length(ans)[%d]!=ngrpcols[%d]+njval[%d]"
msgstr ""

#: dogroups.c:426
#, c-format
msgid ""
"Column %d of result for group %d is type '%s' but expecting type '%s'. "
"Column types must be consistent for each group."
msgstr ""

#: dogroups.c:428
#, c-format
msgid ""
"Supplied %d items for column %d of group %d which has %d rows. The RHS "
"length must either be 1 (single values are ok) or match the LHS length "
"exactly. If you wish to 'recycle' the RHS please use rep() explicitly to "
"make this intent clear to readers of your code."
msgstr ""

#: dogroups.c:453
#, c-format
msgid "Internal error: block 0 [%d] and block 1 [%d] have both run"
msgstr ""

#: dogroups.c:481
msgid "growVector passed NULL"
msgstr ""

#: fastmean.c:39
msgid "narm should be TRUE or FALSE"
msgstr ""

#: fastmean.c:45
#, c-format
msgid "fastmean was passed type %s, not numeric or logical"
msgstr ""

#: fastmean.c:83 fastmean.c:111
#, c-format
msgid "Internal error: type '%s' not caught earlier in fastmean"
msgstr ""

#: fcast.c:80
#, c-format
msgid "Unsupported column type in fcast val: '%s'"
msgstr ""

#: fifelse.c:5
msgid "Argument 'test' must be logical."
msgstr ""

#: fifelse.c:23
#, c-format
msgid ""
"'yes' is of type %s but 'no' is of type %s. Please make sure that both "
"arguments have the same type."
msgstr ""

#: fifelse.c:28
msgid ""
"'yes' has different class than 'no'. Please make sure that both arguments "
"have the same class."
msgstr ""

#: fifelse.c:33
msgid "'yes' and 'no' are both type factor but their levels are different."
msgstr ""

#: fifelse.c:38
#, c-format
msgid "Length of 'yes' is %lld but must be 1 or length of 'test' (%lld)."
msgstr ""

#: fifelse.c:40
#, c-format
msgid "Length of 'no' is %lld but must be 1 or length of 'test' (%lld)."
msgstr ""

#: fifelse.c:51
#, c-format
msgid "Length of 'na' is %lld but must be 1"
msgstr ""

#: fifelse.c:57
#, c-format
msgid ""
"'yes' is of type %s but 'na' is of type %s. Please make sure that both "
"arguments have the same type."
msgstr ""

#: fifelse.c:59
msgid ""
"'yes' has different class than 'na'. Please make sure that both arguments "
"have the same class."
msgstr ""

#: fifelse.c:63
msgid "'yes' and 'na' are both type factor but their levels are different."
msgstr ""

#: fifelse.c:133
#, c-format
msgid "Type %s is not supported."
msgstr ""

#: fmelt.c:18
msgid "'x' must be an integer"
msgstr ""

#: fmelt.c:19
msgid "'n' must be a positive integer"
msgstr ""

#: fmelt.c:41
msgid "Argument to 'which' must be logical"
msgstr ""

#: fmelt.c:70
msgid "concat: 'vec must be a character vector"
msgstr ""

#: fmelt.c:71
msgid "concat: 'idx' must be an integer vector of length >= 0"
msgstr ""

#: fmelt.c:75
msgid ""
"concat: 'idx' must take values between 0 and length(vec); 0 <= idx <= "
"length(vec)"
msgstr ""

#: fmelt.c:102
#, c-format
msgid "Unknown 'measure.vars' type %s at index %d of list"
msgstr ""

#: fmelt.c:154 fmelt.c:219
#, c-format
msgid "Unknown 'id.vars' type %s, must be character or integer vector"
msgstr ""

#: fmelt.c:159 fmelt.c:223
msgid "One or more values in 'id.vars' is invalid."
msgstr ""

#: fmelt.c:184
#, c-format
msgid ""
"Unknown 'measure.vars' type %s, must be character or integer vector/list"
msgstr ""

#: fmelt.c:193 fmelt.c:239
msgid "One or more values in 'measure.vars' is invalid."
msgstr ""

#: fmelt.c:231
#, c-format
msgid "Unknown 'measure.vars' type %s, must be character or integer vector"
msgstr ""

#: fmelt.c:276
msgid ""
"When 'measure.vars' is a list, 'value.name' must be a character vector of "
"length =1 or =length(measure.vars)."
msgstr ""

#: fmelt.c:277
msgid ""
"When 'measure.vars' is either not specified or a character/integer vector, "
"'value.name' must be a character vector of length =1."
msgstr ""

#: fmelt.c:280
msgid "'variable.name' must be a character/integer vector of length=1."
msgstr ""

#: fmelt.c:329
msgid ""
"Internal error: combineFactorLevels in fmelt.c expects all-character input"
msgstr ""

#: fmelt.c:332
msgid ""
"Internal error: combineFactorLevels in fmelt.c expects a character target to "
"factorize"
msgstr ""

#: fmelt.c:490
#, c-format
msgid "Unknown column type '%s' for column '%s'."
msgstr ""

#: fmelt.c:514
#, c-format
msgid "Internal error: fmelt.c:getvarcols %d %d"
msgstr ""

#: fmelt.c:662
#, c-format
msgid "Unknown column type '%s' for column '%s' in 'data'"
msgstr ""

#: fmelt.c:673
msgid "Input is not of type VECSXP, expected a data.table, data.frame or list"
msgstr ""

#: fmelt.c:674
msgid "Argument 'value.factor' should be logical TRUE/FALSE"
msgstr ""

#: fmelt.c:675
msgid "Argument 'variable.factor' should be logical TRUE/FALSE"
msgstr ""

#: fmelt.c:676
msgid "Argument 'na.rm' should be logical TRUE/FALSE."
msgstr ""

#: fmelt.c:677
msgid "Argument 'variable.name' must be a character vector"
msgstr ""

#: fmelt.c:678
msgid "Argument 'value.name' must be a character vector"
msgstr ""

#: fmelt.c:679
msgid "Argument 'verbose' should be logical TRUE/FALSE"
msgstr ""

#: fmelt.c:687
msgid "names(data) is NULL. Please report to data.table-help"
msgstr ""

#: forder.c:374
msgid "Must an integer or numeric vector length 1"
msgstr ""

#: forder.c:375
msgid "Must be 2, 1 or 0"
msgstr ""

#: forder.c:431
msgid ""
"Internal error: input is not either a list of columns, or an atomic vector."
msgstr ""

#: forder.c:433
msgid ""
"Internal error: input is an atomic vector (not a list of columns) but by= is "
"not NULL"
msgstr ""

#: forder.c:435
msgid ""
"Input is an atomic vector (not a list of columns) but order= is not a length "
"1 integer"
msgstr ""

#: forder.c:448
msgid "Internal error: DT is an empty list() of 0 columns"
msgstr ""

#: forder.c:450
#, c-format
msgid ""
"Internal error: DT has %d columns but 'by' is either not integer or is "
"length 0"
msgstr ""

#: forder.c:452
#, c-format
msgid ""
"Either order= is not integer or its length (%d) is different to by='s length "
"(%d)"
msgstr ""

#: forder.c:458
#, c-format
msgid "internal error: 'by' value %d out of range [1,%d]"
msgstr ""

#: forder.c:460
#, c-format
msgid "Column %d is length %d which differs from length of column 1 (%d)\n"
msgstr ""

#: forder.c:464
msgid "retGrp= must be TRUE or FALSE"
msgstr ""

#: forder.c:467
msgid "sort= must be TRUE or FALSE"
msgstr ""

#: forder.c:470
msgid "At least one of retGrp= or sort= must be TRUE"
msgstr ""

#: forder.c:472
msgid "na.last must be logical TRUE, FALSE or NA of length 1"
msgstr ""

#: forder.c:1301
msgid "x must be either NULL or an integer vector"
msgstr ""

#: forder.c:1303
msgid "nrow must be integer vector length 1"
msgstr ""

#: forder.c:1305
#, c-format
msgid "nrow==%d but must be >=0"
msgstr ""

#: forder.c:1322
msgid "x must be type 'double'"
msgstr ""

#: frank.c:11
#, c-format
msgid "Internal error. Argument 'x' to Cdt_na is type '%s' not 'list'"
msgstr ""

#: frank.c:12
#, c-format
msgid "Internal error. Argument 'cols' to Cdt_na is type '%s' not 'integer'"
msgstr ""

#: frank.c:16 frank.c:146 subset.c:263
#, c-format
msgid "Item %d of 'cols' is %d which is outside 1-based range [1,ncol(x)=%d]"
msgstr ""

#: frank.c:26 frank.c:155
#, c-format
msgid ""
"Column %d of input list x is length %d, inconsistent with first column of "
"that item which is length %d."
msgstr ""

#: frank.c:65 frank.c:202 transpose.c:88
#, c-format
msgid "Unsupported column type '%s'"
msgstr ""

#: frank.c:83
msgid ""
"Internal error: invalid ties.method for frankv(), should have been caught "
"before. please report to data.table issue tracker"
msgstr ""

#: frank.c:130
#, c-format
msgid "Internal error: unknown ties value in frank: %d"
msgstr ""

#: frank.c:141
#, c-format
msgid "Internal error. Argument 'x' to CanyNA is type '%s' not 'list'"
msgstr ""

#: frank.c:142
#, c-format
msgid "Internal error. Argument 'cols' to CanyNA is type '%s' not 'integer'"
msgstr ""

#: freadR.c:84
msgid ""
"Internal error: freadR input not a single character string: a filename or "
"the data itself. Should have been caught at R level."
msgstr ""

#: freadR.c:101
msgid ""
"Internal error: freadR sep not a single character. R level catches this."
msgstr ""

#: freadR.c:105
msgid ""
"Internal error: freadR dec not a single character. R level catches this."
msgstr ""

#: freadR.c:112
msgid "quote= must be a single character, blank \")\", or FALSE"
msgstr ""

#: freadR.c:137
msgid "Internal error: skip not integer or string in freadR.c"
msgstr ""

#: freadR.c:140
#, c-format
msgid "Internal error: NAstringsArg is type '%s'. R level catches this"
msgstr ""

#: freadR.c:153
#, c-format
msgid "nThread(%d)<1"
msgstr ""

#: freadR.c:160
msgid "'integer64' must be a single character string"
msgstr ""

#: freadR.c:660
#, c-format
msgid "%s"
msgstr ""

#: froll.c:428
#, c-format
msgid "%s: results from provided FUN are not length 1"
msgstr ""

#: froll.c:438
#, c-format
msgid "%s: results from provided FUN are not of type double"
msgstr ""

#: frollR.c:15
msgid "x must be of type numeric or logical"
msgstr ""

#: frollR.c:26
msgid "x must be list, data.frame or data.table of numeric or logical types"
msgstr ""

#: frollR.c:47 frollR.c:264
msgid "n must be non 0 length"
msgstr ""

#: frollR.c:50
msgid "adaptive must be TRUE or FALSE"
msgstr ""

#: frollR.c:58
msgid "n must be integer, list is accepted for adaptive TRUE"
msgstr ""

#: frollR.c:65 frollR.c:256 frollR.c:259
msgid "n must be integer"
msgstr ""

#: frollR.c:72
msgid "n must be positive integer values (> 0)"
msgstr ""

#: frollR.c:81 frollR.c:93
msgid "n must be integer vector or list of integer vectors"
msgstr ""

#: frollR.c:104 gsumm.c:342 gsumm.c:577 gsumm.c:686 gsumm.c:805 gsumm.c:950
#: gsumm.c:1262 gsumm.c:1403 uniqlist.c:350
msgid "na.rm must be TRUE or FALSE"
msgstr ""

#: frollR.c:107
msgid "hasNA must be TRUE, FALSE or NA"
msgstr ""

#: frollR.c:109
msgid ""
"using hasNA FALSE and na.rm TRUE does not make sense, if you know there are "
"NA values use hasNA TRUE, otherwise leave it as default NA"
msgstr ""

#: frollR.c:119 frollR.c:275
msgid ""
"Internal error: invalid align argument in rolling function, should have been "
"caught before. please report to data.table issue tracker."
msgstr ""

#: frollR.c:122
msgid ""
"using adaptive TRUE and align argument different than 'right' is not "
"implemented"
msgstr ""

#: frollR.c:135
msgid ""
"adaptive rolling function can only process 'x' having equal length of "
"elements, like data.table or data.frame; If you want to call rolling "
"function on list having variable length of elements call it for each field "
"separately"
msgstr ""

#: frollR.c:137
msgid ""
"length of integer vector(s) provided as list to 'n' argument must be equal "
"to number of observations provided in 'x'"
msgstr ""

#: frollR.c:151
msgid ""
"Internal error: invalid fun argument in rolling function, should have been "
"caught before. please report to data.table issue tracker."
msgstr ""

#: frollR.c:155 frollR.c:279 nafill.c:136 shift.c:21
msgid "fill must be a vector of length 1"
msgstr ""

#: frollR.c:169 frollR.c:292
msgid "fill must be numeric"
msgstr ""

#: frollR.c:185
msgid ""
"Internal error: invalid algo argument in rolling function, should have been "
"caught before. please report to data.table issue tracker."
msgstr ""

#: frollR.c:190
#, c-format
msgid "Internal error: badaptive=%d but ik is not integer"
msgstr ""

#: frollR.c:219
#, c-format
msgid "Internal error: Unknown sfun value in froll: %d"
msgstr ""

#: frollR.c:238
msgid "internal error: 'fun' must be a function"
msgstr ""

#: frollR.c:240
msgid "internal error: 'rho' should be an environment"
msgstr ""

#: fsort.c:111
msgid "x must be a vector of type 'double' currently"
msgstr ""

#: fsort.c:157
msgid "Cannot yet handle negatives."
msgstr ""

#: fsort.c:173
msgid "Unable to allocate working memory"
msgstr ""

#: fsort.c:230
msgid "Internal error: counts[nBatch-1][MSBsize-1] != length(x)"
msgstr ""

#: fwriteR.c:41
msgid "Internal error: col passed to getMaxCategLen is missing levels"
msgstr ""

#: fwriteR.c:75
msgid "Internal error: getMaxListItemLen should have caught this up front."
msgstr ""

#: fwriteR.c:98
#, c-format
msgid ""
"Row %d of list column is type '%s' - not yet implemented. fwrite() can write "
"list columns containing items which are atomic vectors of"
msgstr ""

#: fwriteR.c:170
msgid ""
"fwrite must be passed an object of type list; e.g. data.frame, data.table"
msgstr ""

#: fwriteR.c:234
#, c-format
msgid "Column %d's length (%d) is not the same as column 1's length (%d)"
msgstr ""

#: fwriteR.c:237
#, c-format
msgid "Column %d's type is '%s' - not yet implemented in fwrite."
msgstr ""

#: fwriteR.c:270
#, c-format
msgid ""
"sep ('%c'), sep2 ('%c') and dec ('%c') must all be different. Column %d is a "
"list column."
msgstr ""

#: gsumm.c:43
msgid "env is not an environment"
msgstr ""

#: gsumm.c:45
msgid "o is not an integer vector"
msgstr ""

#: gsumm.c:46
msgid "f is not an integer vector"
msgstr ""

#: gsumm.c:47
msgid "l is not an integer vector"
msgstr ""

#: gsumm.c:56
msgid "irowsArg is neither an integer vector nor NULL"
msgstr ""

#: gsumm.c:58
#, c-format
msgid "length(f)=%d != length(l)=%d"
msgstr ""

#: gsumm.c:66
#, c-format
msgid "o has length %d but sum(l)=%d"
msgstr ""

#: gsumm.c:69
msgid "Internal error: o's maxgrpn attribute mismatches recalculated maxgrpn"
msgstr ""

#: gsumm.c:89
#, c-format
msgid ""
"Internal error: nrow=%d  ngrp=%d  nbit=%d  shift=%d  highSize=%d  nBatch=%d  "
"batchSize=%d  lastBatchSize=%d\n"
msgstr ""

#: gsumm.c:116
msgid ""
"Internal error: Failed to allocate counts or TMP when assigning g in gforce"
msgstr ""

#: gsumm.c:334
#, c-format
msgid "gather implemented for INTSXP, REALSXP, and CPLXSXP but not '%s'"
msgstr ""

#: gsumm.c:345
msgid "sum is not meaningful for factors."
msgstr ""

#: gsumm.c:350 gsumm.c:606
#, c-format
msgid "nrow [%d] != length(x) [%d] in gsum"
msgstr ""

#: gsumm.c:565
#, c-format
msgid ""
"Type '%s' not supported by GForce sum (gsum). Either add the prefix base::"
"sum(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:578
msgid ""
"GForce mean can only be applied to columns, not .SD or similar. Likely "
"you're looking for 'DT[,lapply(.SD,mean),by=,.SDcols=]'. See ?data.table."
msgstr ""

#: gsumm.c:579
msgid "mean is not meaningful for factors."
msgstr ""

#: gsumm.c:599
#, c-format
msgid "Internal error: gsum returned type '%s'. typeof(x) is '%s'"
msgstr ""

#: gsumm.c:609
#, c-format
msgid "Unable to allocate %d * %d bytes for sum in gmean na.rm=TRUE"
msgstr ""

#: gsumm.c:612
#, c-format
msgid "Unable to allocate %d * %d bytes for counts in gmean na.rm=TRUE"
msgstr ""

#: gsumm.c:638
#, c-format
msgid "Unable to allocate %d * %d bytes for si in gmean na.rm=TRUE"
msgstr ""

#: gsumm.c:650
#, c-format
msgid ""
"Type '%s' not supported by GForce mean (gmean) na.rm=TRUE. Either add the "
"prefix base::mean(.) or turn off GForce optimization using options(datatable."
"optimize=1)"
msgstr ""

#: gsumm.c:674
msgid "Internal error: unsupported type at the end of gmean"
msgstr ""

#: gsumm.c:687
msgid ""
"GForce min can only be applied to columns, not .SD or similar. To find min "
"of all items in a list such as .SD, either add the prefix base::min(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,min),by=,.SDcols=]'"
msgstr ""

#: gsumm.c:688
msgid "min is not meaningful for factors."
msgstr ""

#: gsumm.c:693
#, c-format
msgid "nrow [%d] != length(x) [%d] in gmin"
msgstr ""

#: gsumm.c:791
msgid "Type 'complex' has no well-defined min"
msgstr ""

#: gsumm.c:794
#, c-format
msgid ""
"Type '%s' not supported by GForce min (gmin). Either add the prefix base::"
"min(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:806
msgid ""
"GForce max can only be applied to columns, not .SD or similar. To find max "
"of all items in a list such as .SD, either add the prefix base::max(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,max),by=,.SDcols=]'"
msgstr ""

#: gsumm.c:807
msgid "max is not meaningful for factors."
msgstr ""

#: gsumm.c:812
#, c-format
msgid "nrow [%d] != length(x) [%d] in gmax"
msgstr ""

#: gsumm.c:937
msgid "Type 'complex' has no well-defined max"
msgstr ""

#: gsumm.c:940
#, c-format
msgid ""
"Type '%s' not supported by GForce max (gmax). Either add the prefix base::"
"max(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:951
msgid ""
"GForce median can only be applied to columns, not .SD or similar. To find "
"median of all items in a list such as .SD, either add the prefix stats::"
"median(.SD) or turn off GForce optimization using options(datatable."
"optimize=1). More likely, you may be looking for 'DT[,lapply(.SD,median),"
"by=,.SDcols=]'"
msgstr ""

#: gsumm.c:952
msgid "median is not meaningful for factors."
msgstr ""

#: gsumm.c:955
#, c-format
msgid "nrow [%d] != length(x) [%d] in gmedian"
msgstr ""

#: gsumm.c:992
#, c-format
msgid ""
"Type '%s' not supported by GForce median (gmedian). Either add the prefix "
"stats::median(.) or turn "
msgstr ""

#: gsumm.c:1006
#, c-format
msgid "nrow [%d] != length(x) [%d] in gtail"
msgstr ""

#: gsumm.c:1074
#, c-format
msgid ""
"Type '%s' not supported by GForce tail (gtail). Either add the prefix utils::"
"tail(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:1086 gsumm.c:1177
#, c-format
msgid "nrow [%d] != length(x) [%d] in ghead"
msgstr ""

#: gsumm.c:1154
#, c-format
msgid ""
"Type '%s' not supported by GForce head (ghead). Either add the prefix utils::"
"head(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:1162
msgid ""
"Internal error, gtail is only implemented for n=1. This should have been "
"caught before. please report to data.table issue tracker."
msgstr ""

#: gsumm.c:1167
msgid ""
"Internal error, ghead is only implemented for n=1. This should have been "
"caught before. please report to data.table issue tracker."
msgstr ""

#: gsumm.c:1173
msgid ""
"Internal error, `g[` (gnthvalue) is only implemented single value subsets "
"with positive index, e.g., .SD[2]. This should have been caught before. "
"please report to data.table issue tracker."
msgstr ""

#: gsumm.c:1251
#, c-format
msgid ""
"Type '%s' not supported by GForce subset `[` (gnthvalue). Either add the "
"prefix utils::head(.) or turn off GForce optimization using "
"options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:1263
msgid ""
"GForce var/sd can only be applied to columns, not .SD or similar. For the "
"full covariance matrix of all items in a list such as .SD, either add the "
"prefix stats::var(.SD) (or stats::sd(.SD)) or turn off GForce optimization "
"using options(datatable.optimize=1). Alternatively, if you only need the "
"diagonal elements, 'DT[,lapply(.SD,var),by=,.SDcols=]' is the optimized way "
"to do this."
msgstr ""

#: gsumm.c:1264
msgid "var/sd is not meaningful for factors."
msgstr ""

#: gsumm.c:1267
#, c-format
msgid "nrow [%d] != length(x) [%d] in gvar"
msgstr ""

#: gsumm.c:1383
#, c-format
msgid ""
"Type '%s' not supported by GForce var (gvar). Either add the prefix stats::"
"var(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:1385
#, c-format
msgid ""
"Type '%s' not supported by GForce sd (gsd). Either add the prefix stats::"
"sd(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: gsumm.c:1404
msgid ""
"GForce prod can only be applied to columns, not .SD or similar. To multiply "
"all items in a list such as .SD, either add the prefix base::prod(.SD) or "
"turn off GForce optimization using options(datatable.optimize=1). More "
"likely, you may be looking for 'DT[,lapply(.SD,prod),by=,.SDcols=]'"
msgstr ""

#: gsumm.c:1405
msgid "prod is not meaningful for factors."
msgstr ""

#: gsumm.c:1410
#, c-format
msgid "nrow [%d] != length(x) [%d] in gprod"
msgstr ""

#: gsumm.c:1412
#, c-format
msgid "Unable to allocate %d * %d bytes for gprod"
msgstr ""

#: gsumm.c:1447
#, c-format
msgid ""
"Type '%s' not supported by GForce prod (gprod). Either add the prefix base::"
"prod(.) or turn off GForce optimization using options(datatable.optimize=1)"
msgstr ""

#: ijoin.c:22 ijoin.c:243
msgid ""
"Internal error: invalid value for 'mult'; this should have been caught "
"before. please report to data.table issue tracker"
msgstr ""

#: ijoin.c:29 ijoin.c:250
msgid ""
"Internal error: invalid value for 'type'; this should have been caught "
"before. please report to data.table issue tracker"
msgstr ""

#: ijoin.c:56 ijoin.c:121
#, c-format
msgid "Internal error: unknown type in mult=%d in lookup: %d"
msgstr ""

#: ijoin.c:124 ijoin.c:215
#, c-format
msgid "Internal error: unknown mult in lookup: %d"
msgstr ""

#: ijoin.c:160
#, c-format
msgid "Internal error: unknown type lookup should have been caught earlier: %d"
msgstr ""

#: ijoin.c:212
#, c-format
msgid ""
"Internal error: unknown type in mult=%d in lookup should have been caught "
"earlier: %d"
msgstr ""

#: ijoin.c:323
#, c-format
msgid "Internal error: unknown type in mult=ALL in overlaps: %d"
msgstr ""

#: ijoin.c:464 ijoin.c:571 ijoin.c:720
#, c-format
msgid "Internal error: unknown type in mult=%d in overlaps: %d"
msgstr ""

#: ijoin.c:723
#, c-format
msgid "Internal error: unknown mult in overlaps: %d"
msgstr ""

#: init.c:198
#, c-format
msgid ""
"Pointers are %d bytes, greater than 8. We have not tested on any "
"architecture greater than 64bit yet."
msgstr ""

#: init.c:209
#, c-format
msgid "Checking NA_INTEGER [%d] == INT_MIN [%d] %s"
msgstr ""

#: init.c:210
#, c-format
msgid "Checking NA_INTEGER [%d] == NA_LOGICAL [%d] %s"
msgstr ""

#: init.c:211
#, c-format
msgid "Checking sizeof(int) [%d] is 4 %s"
msgstr ""

#: init.c:212
#, c-format
msgid "Checking sizeof(double) [%d] is 8 %s"
msgstr ""

#: init.c:214
#, c-format
msgid "Checking sizeof(long long) [%d] is 8 %s"
msgstr ""

#: init.c:215
#, c-format
msgid "Checking sizeof(pointer) [%d] is 4 or 8 %s"
msgstr ""

#: init.c:216
#, c-format
msgid "Checking sizeof(SEXP) [%d] == sizeof(pointer) [%d] %s"
msgstr ""

#: init.c:217
#, c-format
msgid "Checking sizeof(uint64_t) [%d] is 8 %s"
msgstr ""

#: init.c:218
#, c-format
msgid "Checking sizeof(int64_t) [%d] is 8 %s"
msgstr ""

#: init.c:219
#, c-format
msgid "Checking sizeof(signed char) [%d] is 1 %s"
msgstr ""

#: init.c:220
#, c-format
msgid "Checking sizeof(int8_t) [%d] is 1 %s"
msgstr ""

#: init.c:221
#, c-format
msgid "Checking sizeof(uint8_t) [%d] is 1 %s"
msgstr ""

#: init.c:222
#, c-format
msgid "Checking sizeof(int16_t) [%d] is 2 %s"
msgstr ""

#: init.c:223
#, c-format
msgid "Checking sizeof(uint16_t) [%d] is 2 %s"
msgstr ""

#: init.c:226
#, c-format
msgid "Checking LENGTH(allocVector(INTSXP,2)) [%d] is 2 %s"
msgstr ""

#: init.c:227
#, c-format
msgid "Checking TRUELENGTH(allocVector(INTSXP,2)) [%d] is 0 %s"
msgstr ""

#: init.c:234
#, c-format
msgid "Checking memset(&i,0,sizeof(int)); i == (int)0 %s"
msgstr ""

#: init.c:237
#, c-format
msgid "Checking memset(&ui, 0, sizeof(unsigned int)); ui == (unsigned int)0 %s"
msgstr ""

#: init.c:240
#, c-format
msgid "Checking memset(&d, 0, sizeof(double)); d == (double)0.0 %s"
msgstr ""

#: init.c:243
#, c-format
msgid "Checking memset(&ld, 0, sizeof(long double)); ld == (long double)0.0 %s"
msgstr ""

#: init.c:246
msgid "The ascii character '/' is not just before '0'"
msgstr ""

#: init.c:247
msgid "The C expression (uint_fast8_t)('/'-'0')<10 is true. Should be false."
msgstr ""

#: init.c:248
msgid "The ascii character ':' is not just after '9'"
msgstr ""

#: init.c:249
msgid "The C expression (uint_fast8_t)('9'-':')<10 is true. Should be false."
msgstr ""

#: init.c:254
#, c-format
msgid "Conversion of NA_INT64 via double failed %lld!=%lld"
msgstr ""

#: init.c:258
msgid "NA_INT64_D (negative -0.0) is not == 0.0."
msgstr ""

#: init.c:259
msgid "NA_INT64_D (negative -0.0) is not ==-0.0."
msgstr ""

#: init.c:260
msgid "ISNAN(NA_INT64_D) is TRUE but should not be"
msgstr ""

#: init.c:261
msgid "isnan(NA_INT64_D) is TRUE but should not be"
msgstr ""

#: init.c:290
#, c-format
msgid "PRINTNAME(install(\")integer64\")) has returned %s not %s"
msgstr ""

#: init.c:359
msgid ".Last.value in namespace is not a length 1 integer"
msgstr ""

#: nafill.c:83
msgid ""
"'x' argument is atomic vector, in-place update is supported only for list/"
"data.table"
msgstr ""

#: nafill.c:85 nafill.c:95
msgid "'x' argument must be numeric type, or list/data.table of numeric types"
msgstr ""

#: nafill.c:133 nafill.c:161
msgid ""
"Internal error: invalid type argument in nafillR function, should have been "
"caught before. Please report to data.table issue tracker."
msgstr ""

#: openmp-utils.c:67
msgid "'verbose' must be TRUE or FALSE"
msgstr ""

#: openmp-utils.c:91
msgid ""
"restore_after_fork= must be TRUE, FALSE, or NULL (default). "
"getDTthreads(verbose=TRUE) reports the current setting.\n"
msgstr ""

#: openmp-utils.c:105
#, c-format
msgid ""
"threads= must be either NULL (default) or a single number. It has length %d"
msgstr ""

#: openmp-utils.c:107
msgid "threads= must be either NULL (default) or type integer/numeric"
msgstr ""

#: openmp-utils.c:109
msgid ""
"threads= must be either NULL or a single integer >= 0. See ?setDTthreads."
msgstr ""

#: openmp-utils.c:114
msgid "Internal error: percent= must be TRUE or FALSE at C level"
msgstr ""

#: openmp-utils.c:117
#, c-format
msgid ""
"Internal error: threads==%d should be between 2 and 100 (percent=TRUE at C "
"level)."
msgstr ""

#: rbindlist.c:8
msgid "fill= should be TRUE or FALSE"
msgstr ""

#: rbindlist.c:10
msgid "use.names= should be TRUE, FALSE, or not used (\")check\" by default)"
msgstr ""

#: rbindlist.c:12
msgid ""
"Input to rbindlist must be a list. This list can contain data.tables, data."
"frames or plain lists."
msgstr ""

#: rbindlist.c:20
msgid "Internal error: rbindlist.c idcol is not a single string"
msgstr ""

#: rbindlist.c:31
#, c-format
msgid "Item %d of input is not a data.frame, data.table or list"
msgstr ""

#: rbindlist.c:39
#, c-format
msgid ""
"Item %d has %d columns, inconsistent with item %d which has %d columns. To "
"fill missing columns use fill=TRUE."
msgstr ""

#: rbindlist.c:42
#, c-format
msgid "Item %d has %d columns but %d column names. Invalid object."
msgstr ""

#: rbindlist.c:49
#, c-format
msgid ""
"Column %d of item %d is length %d inconsistent with column %d which is "
"length %d. Only length-1 columns are recycled."
msgstr ""

#: rbindlist.c:62
#, c-format
msgid ""
"Total rows in the list is %lld which is larger than the maximum number of "
"rows, currently %d"
msgstr ""

#: rbindlist.c:63
msgid "use.names=TRUE but no item of input list has any names"
msgstr ""

#: rbindlist.c:71
#, c-format
msgid ""
"Failed to allocate upper bound of %lld unique column names [sum(lapply(l,"
"ncol))]"
msgstr ""

#: rbindlist.c:102
#, c-format
msgid "Failed to allocate nuniq=%d items working memory in rbindlist.c"
msgstr ""

#: rbindlist.c:136
#, c-format
msgid "Failed to allocate ncol=%d items working memory in rbindlist.c"
msgstr ""

#: rbindlist.c:191
msgid ""
"Internal error: usenames==NA but fill=TRUE. usenames should have been set to "
"TRUE earlier with warning."
msgstr ""

#: rbindlist.c:206
msgid ""
"Internal error: could not find the first column name not present in earlier "
"item"
msgstr ""

#: rbindlist.c:218
#, c-format
msgid ""
"Internal error: usenames==NA but an out-of-order name has been found in an "
"item with no names or the first item. [%d]"
msgstr ""

#: rbindlist.c:297
#, c-format
msgid ""
"Column %d of item %d has type 'factor' but has no levels; i.e. malformed."
msgstr ""

#: rbindlist.c:315
#, c-format
msgid ""
"Class attribute on column %d of item %d does not match with column %d of "
"item %d."
msgstr ""

#: rbindlist.c:325
#, c-format
msgid ""
"Internal error: column %d of result is determined to be integer64 but "
"maxType=='%s' != REALSXP"
msgstr ""

#: rbindlist.c:361
#, c-format
msgid ""
"Failed to allocate working memory for %d ordered factor levels of result "
"column %d"
msgstr ""

#: rbindlist.c:432
#, c-format
msgid ""
"Failed to allocate working memory for %d factor levels of result column %d "
"when reading item %d of item %d"
msgstr ""

#: reorder.c:17
#, c-format
msgid "Item %d of list is type '%s' which isn't yet supported (SIZEOF=%d)"
msgstr ""

#: reorder.c:19
#, c-format
msgid ""
"Column %d is length %d which differs from length of column 1 (%d). Invalid "
"data.table."
msgstr ""

#: reorder.c:27
#, c-format
msgid ""
"reorder accepts vectors but this non-VECSXP is type '%s' which isn't yet "
"supported (SIZEOF=%d)"
msgstr ""

#: reorder.c:28
msgid ""
"Internal error in reorder.c: cannot reorder an ALTREP vector. Please see "
"NEWS item 2 in v1.11.4 and report this as a bug."
msgstr ""

#: reorder.c:33
msgid "order must be an integer vector"
msgstr ""

#: reorder.c:34
#, c-format
msgid "nrow(x)[%d]!=length(order)[%d]"
msgstr ""

#: reorder.c:48
#, c-format
msgid "order is not a permutation of 1:nrow[%d]"
msgstr ""

#: reorder.c:57
#, c-format
msgid ""
"Unable to allocate %d * %d bytes of working memory for reordering data.table"
msgstr ""

#: shift.c:17
#, c-format
msgid ""
"type '%s' passed to shift(). Must be a vector, list, data.frame or data.table"
msgstr ""

#: shift.c:24 shift.c:28
msgid ""
"Internal error: invalid type for shift(), should have been caught before. "
"please report to data.table issue tracker"
msgstr ""

#: shift.c:31
msgid "Internal error: k must be integer"
msgstr ""

#: shift.c:33
#, c-format
msgid "Item %d of n is NA"
msgstr ""

#: shift.c:158
#, c-format
msgid "Unsupported type '%s'"
msgstr ""

#: subset.c:7
#, c-format
msgid "Internal error: subsetVectorRaw length(ans)==%d n=%d"
msgstr ""

#: subset.c:88
#, c-format
msgid ""
"Internal error: column type '%s' not supported by data.table subset. All "
"known types are supported so please report as bug."
msgstr ""

#: subset.c:97 subset.c:121
#, c-format
msgid "Internal error. 'idx' is type '%s' not 'integer'"
msgstr ""

#: subset.c:122
#, c-format
msgid ""
"Internal error. 'maxArg' is type '%s' and length %d, should be an integer "
"singleton"
msgstr ""

#: subset.c:123
msgid "Internal error: allowOverMax must be TRUE/FALSE"
msgstr ""

#: subset.c:125
#, c-format
msgid "Internal error. max is %d, must be >= 0."
msgstr ""

#: subset.c:149
#, c-format
msgid "i[%d] is %d which is out of range [1,nrow=%d]"
msgstr ""

#: subset.c:161
#, c-format
msgid ""
"Item %d of i is %d and item %d is %d. Cannot mix positives and negatives."
msgstr ""

#: subset.c:171
#, c-format
msgid "Item %d of i is %d and item %d is NA. Cannot mix negatives and NA."
msgstr ""

#: subset.c:223
#, c-format
msgid "Column %d is NULL; malformed data.table."
msgstr ""

#: subset.c:226
#, c-format
msgid "Column %d ['%s'] is a data.frame or data.table; malformed data.table."
msgstr ""

#: subset.c:231
#, c-format
msgid ""
"Column %d ['%s'] is length %d but column 1 is length %d; malformed data."
"table."
msgstr ""

#: subset.c:247
#, c-format
msgid "Internal error. Argument 'x' to CsubsetDT is type '%s' not 'list'"
msgstr ""

#: subset.c:260
#, c-format
msgid "Internal error. Argument 'cols' to Csubset is type '%s' not 'integer'"
msgstr ""

#: subset.c:337
msgid ""
"Internal error: NULL can not be subset. It is invalid for a data.table to "
"contain a NULL column."
msgstr ""

#: subset.c:339
msgid ""
"Internal error: CsubsetVector is internal-use-only but has received "
"negatives, zeros or out-of-range"
msgstr ""

#: transpose.c:9
msgid "l must be a list."
msgstr ""

#: transpose.c:13
msgid "ignore.empty should be logical TRUE/FALSE."
msgstr ""

#: transpose.c:16
msgid ""
"keep.names should be either NULL, or the name of the first column of the "
"result in which to place the names of the input"
msgstr ""

#: transpose.c:19
msgid "fill must be a length 1 vector, such as the default NA"
msgstr ""

#: transpose.c:28
#, c-format
msgid "Item %d of list input is not an atomic vector"
msgstr ""

#: types.c:23
#, c-format
msgid ""
"%s: %d:\n"
"%s:"
msgstr ""

#: types.c:55
msgid "internal error: status, nx, nk must be integer"
msgstr ""

#: uniqlist.c:14
msgid "Internal error: uniqlist has not been passed a list of columns"
msgstr ""

#: uniqlist.c:17
msgid "Internal error: uniqlist has been passed a non-integer order"
msgstr ""

#: uniqlist.c:18
msgid "Internal error: uniqlist has been passed a length-0 order"
msgstr ""

#: uniqlist.c:19
#, c-format
msgid "Internal error: uniqlist has been passed length(order)==%d but nrow==%d"
msgstr ""

#: uniqlist.c:96 uniqlist.c:127 uniqlist.c:208 uniqlist.c:245 uniqlist.c:318
#, c-format
msgid "Type '%s' not supported"
msgstr ""

#: uniqlist.c:148
msgid "Input argument 'x' to 'uniqlengths' must be an integer vector"
msgstr ""

#: uniqlist.c:149
msgid ""
"Input argument 'n' to 'uniqlengths' must be an integer vector of length 1"
msgstr ""

#: uniqlist.c:167
msgid "cols must be an integer vector with length >= 1"
msgstr ""

#: uniqlist.c:171
#, c-format
msgid "Item %d of cols is %d which is outside range of l [1,length(l)=%d]"
msgstr ""

#: uniqlist.c:174
#, c-format
msgid ""
"All elements to input list must be of same length. Element [%d] has length "
"%llu != length of first element = %llu."
msgstr ""

#: uniqlist.c:255
msgid "Internal error: nestedid was not passed a list length 1 or more"
msgstr ""

#: uniqlist.c:262
#, c-format
msgid "Internal error: nrows[%d]>0 but ngrps==0"
msgstr ""

#: uniqlist.c:264
msgid "cols must be an integer vector of positive length"
msgstr ""

#: uniqlist.c:349
msgid "x is not a logical vector"
msgstr ""

#: utils.c:73
#, c-format
msgid "Unsupported type '%s' passed to allNA()"
msgstr ""

#: utils.c:92
msgid "'x' argument must be data.table compatible"
msgstr ""

#: utils.c:94
msgid "'check_dups' argument must be TRUE or FALSE"
msgstr ""

#: utils.c:110
msgid ""
"argument specifying columns is type 'double' and one or more items in it are "
"not whole integers"
msgstr ""

#: utils.c:116
#, c-format
msgid "argument specifying columns specify non existing column(s): cols[%d]=%d"
msgstr ""

#: utils.c:121
msgid "'x' argument data.table has no names"
msgstr ""

#: utils.c:126
#, c-format
msgid ""
"argument specifying columns specify non existing column(s): cols[%d]='%s'"
msgstr ""

#: utils.c:129
msgid "argument specifying columns must be character or numeric"
msgstr ""

#: utils.c:132
msgid "argument specifying columns specify duplicated column(s)"
msgstr ""

#: utils.c:138
#, c-format
msgid "%s: fill argument must be length 1"
msgstr ""

#: utils.c:171
#, c-format
msgid "%s: fill argument must be numeric"
msgstr ""

#: utils.c:274
#, c-format
msgid "Internal error: unsupported type '%s' passed to copyAsPlain()"
msgstr ""

#: utils.c:278
#, c-format
msgid ""
"Internal error: type '%s' passed to copyAsPlain() but it seems "
"copyMostAttrib() retains ALTREP attributes"
msgstr ""

#: vecseq.c:13
msgid "x must be an integer vector"
msgstr ""

#: vecseq.c:14
msgid "len must be an integer vector"
msgstr ""

#: vecseq.c:15
msgid "x and len must be the same length"
msgstr ""

#: vecseq.c:21
msgid ""
"Join results in more than 2^31 rows (internal vecseq reached physical "
"limit). Very likely misspecified join. Check for duplicate key values in i "
"each of which join to the same group in x over and over again. If that's ok, "
"try by=.EACHI to run j for each group to avoid the large allocation. "
"Otherwise, please search for this error message in the FAQ, Wiki, Stack "
"Overflow and data.table issue tracker for advice."
msgstr ""

#: vecseq.c:25
msgid "clamp must be a double vector length 1"
msgstr ""

#: vecseq.c:27
msgid "clamp must be positive"
msgstr ""

#: vecseq.c:28
#, c-format
msgid ""
"Join results in %d rows; more than %d = nrow(x)+nrow(i). Check for duplicate "
"key values in i each of which join to the same group in x over and over "
"again. If that's ok, try by=.EACHI to run j for each group to avoid the "
"large allocation. If you are sure you wish to proceed, rerun with allow."
"cartesian=TRUE. Otherwise, please search for this error message in the FAQ, "
"Wiki, Stack Overflow and data.table issue tracker for advice."
msgstr ""

#: wrappers.c:11
msgid "Attribute name must be a character vector of length 1"
msgstr ""

#: wrappers.c:16
msgid ""
"Internal structure doesn't seem to be a list. Can't set class to be 'data."
"table' or 'data.frame'. Use 'as.data.table()' or 'as.data.frame()' methods "
"instead."
msgstr ""

#: wrappers.c:59
msgid "First argument to setlistelt must be a list()"
msgstr ""

#: wrappers.c:60
msgid "Second argument to setlistelt must a length 1 integer vector"
msgstr ""

#: wrappers.c:62
#, c-format
msgid "i (%d) is outside the range of items [1,%d]"
msgstr ""

#: wrappers.c:84
msgid "x isn't a VECSXP"
msgstr ""

#: wrappers.c:99
#, c-format
msgid ""
"dim.data.table expects a data.table as input (which is a list), but seems to "
"be of type %s"
msgstr ""
